{% extends 'base.html' %}
{% block title %}Dashboard Test · Track Insights{% endblock %}

{% block content %}
<section class="dashboard-test">
  <h1>Dashboard Playground</h1>
  <p class="help-text">Use the search box to find an athlete, then load their dashboard data straight from the new API.</p>

  <form id="dashboardSearchForm" class="search-form">
    <label for="dashboardSearchInput">Search athletes or schools</label>
    <div class="search-row">
      <input id="dashboardSearchInput" name="q" type="text" placeholder="e.g. Jane Doe, Park Tudor" required>
      <button type="submit">Search</button>
    </div>
  </form>

  <div id="searchStatus" class="status"></div>
  <div id="searchResults" class="results" aria-live="polite"></div>

  <section id="dashboardOutput" class="dashboard-output" hidden>
    <header class="dashboard-header">
      <h2 id="athleteHeading"></h2>
      <div class="identity">
        <span><strong>School:</strong> <span id="athleteSchool">–</span></span>
        <span><strong>Gender:</strong> <span id="athleteGender">–</span></span>
        <span><strong>Class Year:</strong> <span id="athleteYear">–</span></span>
      </div>
    </header>

    <section class="badges">
      <h3>Badges</h3>
      <div id="badgeList" class="badge-list">No playoff badges yet.</div>
    </section>

    <section class="history">
      <h3>Playoff Result History</h3>
      <table id="historyTable" class="history-table">
        <thead>
          <tr>
            <th scope="col">Year</th>
            <th scope="col">Event</th>
            <th scope="col">Sectional</th>
            <th scope="col">Regional</th>
            <th scope="col">State</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div id="historyEmpty" class="empty-state" hidden>No playoff history recorded.</div>
    </section>

    <section class="personal-bests">
      <h3>Personal Bests (since 2022)</h3>
      <table id="personalBestTable" class="personal-best-table">
        <thead>
          <tr>
            <th scope="col">Event</th>
            <th scope="col">PR</th>
            <th scope="col">Meet</th>
            <th scope="col">School Rank</th>
            <th scope="col">State Rank</th>
            <th scope="col" class="rankings-header">Result Rankings</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div id="personalBestEmpty" class="empty-state" hidden>No personal bests recorded yet.</div>
    </section>

    <section class="raw-json">
      <h3>Raw Response</h3>
      <pre id="rawJson"></pre>
    </section>
  </section>
</section>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const form = document.getElementById('dashboardSearchForm');
    const input = document.getElementById('dashboardSearchInput');
    const status = document.getElementById('searchStatus');
    const results = document.getElementById('searchResults');
    const output = document.getElementById('dashboardOutput');
    const heading = document.getElementById('athleteHeading');
    const schoolSpan = document.getElementById('athleteSchool');
    const genderSpan = document.getElementById('athleteGender');
    const yearSpan = document.getElementById('athleteYear');
    const badgeList = document.getElementById('badgeList');
  const historyTableBody = document.querySelector('#historyTable tbody');
  const historyEmpty = document.getElementById('historyEmpty');
  const personalBestTableBody = document.querySelector('#personalBestTable tbody');
  const personalBestEmpty = document.getElementById('personalBestEmpty');
    const rawJson = document.getElementById('rawJson');
    let currentAthleteId = null;

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      const query = input.value.trim();
      if (!query) {
        status.textContent = 'Enter a search term to continue.';
        return;
      }

      status.textContent = 'Searching…';
      results.innerHTML = '';

      try {
        const response = await fetch(`/api/search?q=${encodeURIComponent(query)}`);
        if (!response.ok) throw new Error('Search failed');
        const data = await response.json();
        const athleteResults = data.filter(item => item.type === 'athlete');
        const otherResults = data.filter(item => item.type !== 'athlete');

        renderSearchResults(athleteResults, otherResults);
        status.textContent = athleteResults.length
          ? 'Select an athlete to load dashboard data.'
          : 'No athlete matches found. Try refining your search.';
      } catch (error) {
        console.error(error);
        status.textContent = 'Something went wrong while searching. Please try again.';
      }
    });

    results.addEventListener('click', async (event) => {
      const button = event.target.closest('button[data-athlete-id]');
      if (!button) return;

      const athleteId = button.dataset.athleteId;
      setLoadingState(true, `Loading dashboard for athlete #${athleteId}…`);

      try {
        const response = await fetch(`/api/athletes/${athleteId}/dashboard`);
        if (!response.ok) throw new Error('Dashboard fetch failed');
        const data = await response.json();
        renderDashboard(data);
        status.textContent = `Loaded dashboard for ${data.athlete.full_name}.`;
      } catch (error) {
        console.error(error);
        status.textContent = 'Unable to load dashboard data for that athlete.';
      } finally {
        setLoadingState(false);
      }
    });

    function renderSearchResults(athleteResults, otherResults) {
      const fragments = [];

      if (athleteResults.length) {
        fragments.push('<h2>Matching athletes</h2>');
        fragments.push('<div class="result-grid">');
        for (const athlete of athleteResults) {
          const subtitle = athlete.school ? ` — ${athlete.school}` : '';
          fragments.push(`
            <button type="button" class="result-card" data-athlete-id="${athlete.id}">
              <span class="result-type">Athlete</span>
              <span class="result-title">${escapeHtml(athlete.name)}</span>
              ${athlete.gender ? `<span class="result-meta">${athlete.gender}${athlete.classYear ? ' · Class of ' + athlete.classYear : ''}</span>` : ''}
              ${athlete.school ? `<span class="result-school">${escapeHtml(athlete.school)}</span>` : ''}
            </button>
          `);
        }
        fragments.push('</div>');
      }

      if (otherResults.length) {
        fragments.push('<h2>Matching schools</h2>');
        fragments.push('<div class="result-grid passive">');
        for (const item of otherResults) {
          fragments.push(`
            <div class="result-card passive">
              <span class="result-type">School</span>
              <span class="result-title">${escapeHtml(item.name)}</span>
            </div>
          `);
        }
        fragments.push('</div>');
      }

      results.innerHTML = fragments.join('') || '<p>No results yet — try a search.</p>';
    }

    function renderDashboard(data) {
      output.hidden = false;
      currentAthleteId = data.athlete.id;
      heading.textContent = data.athlete.full_name || `${data.athlete.first} ${data.athlete.last}`;
      schoolSpan.textContent = data.athlete.school || '—';
      genderSpan.textContent = data.athlete.gender || '—';
      yearSpan.textContent = data.athlete.graduation_year || '—';

      renderBadges(data.badges);
      renderHistory(data.playoff_history);
      renderPersonalBests(data.personal_bests);
      rawJson.textContent = JSON.stringify(data, null, 2);
    }

    function renderBadges(badges) {
      const rendered = [];
      for (const [stage, badge] of Object.entries(badges || {})) {
        if (!badge) continue;
        const details = [];
        if (badge.best_percentile !== undefined) {
          details.push(`Best Percentile: ${badge.best_percentile.toFixed ? badge.best_percentile.toFixed(1) : badge.best_percentile}%`);
        }
        if (badge.achievement) {
          details.push(`${badge.count ? badge.count + ' × ' : ''}${badge.achievement}`);
        }
        rendered.push(`
          <div class="badge-card">
            <div class="badge-stage">${escapeHtml(badge.stage || stage)}</div>
            <div class="badge-label">${escapeHtml(badge.label || '')}</div>
            ${details.length ? `<div class="badge-details">${details.map(escapeHtml).join(' · ')}</div>` : ''}
          </div>
        `);
      }

      badgeList.innerHTML = rendered.join('') || 'No playoff badges yet.';
    }

    function renderHistory(rows) {
      if (!rows || !rows.length) {
        historyTableBody.innerHTML = '';
        historyEmpty.hidden = false;
        return;
      }

      historyEmpty.hidden = true;
      historyTableBody.innerHTML = rows.map(row => `
        <tr>
          <td>${escapeHtml(row.year)}</td>
          <td>${escapeHtml(row.event)}</td>
          <td>${escapeHtml(row.sectional)}</td>
          <td>${escapeHtml(row.regional)}</td>
          <td>${escapeHtml(row.state)}</td>
        </tr>
      `).join('');
    }

    function renderPersonalBests(entries) {
      if (!entries || !entries.length) {
        personalBestTableBody.innerHTML = '';
        personalBestEmpty.hidden = false;
        return;
      }

      personalBestEmpty.hidden = true;
      personalBestTableBody.innerHTML = entries.map(entry => `
        <tr data-meet-id="${entry.meet_id || ''}" data-event="${encodeURIComponent(entry.event)}" data-result-type="${entry.result_type || 'Final'}">
          <td>${escapeHtml(entry.event)}</td>
          <td>
            <div class="pb-primary">${escapeHtml(entry.result)}</div>
            <div class="pb-secondary">${escapeHtml(entry.event_type || '')}</div>
          </td>
          <td>
            <div class="pb-primary">${escapeHtml(entry.meet_type || '—')}</div>
            <div class="pb-secondary">${escapeHtml(entry.year || '—')}</div>
          </td>
          <td>${escapeHtml(formatRank(entry.school_rank))}</td>
          <td>${escapeHtml(formatRank(entry.state_rank))}</td>
          <td>
            ${entry.meet_id ? `<button type="button" class="ranking-button" data-action="view-rankings">View Rankings</button>` : '<span class="muted">Unavailable</span>'}
            <div class="ranking-popover" hidden>
              <div class="ranking-popover__content">
                <button type="button" class="ranking-popover__close" aria-label="Close rankings">×</button>
                <div class="ranking-popover__status">Loading…</div>
                <div class="ranking-popover__body" hidden>
                  <h4>Result Rankings</h4>
                  <div class="ranking-summary" data-cohort="overall"></div>
                  <div class="ranking-summary" data-cohort="like_schools"></div>
                  <div class="ranking-summary" data-cohort="same_grade"></div>
                </div>
              </div>
            </div>
          </td>
        </tr>
      `).join('');

      personalBestTableBody.querySelectorAll('.ranking-button').forEach(button => {
        button.addEventListener('click', handleRankingButtonClick);
      });

      personalBestTableBody.querySelectorAll('.ranking-popover__close').forEach(button => {
        button.addEventListener('click', event => {
          const popover = event.target.closest('.ranking-popover');
          if (popover) {
            popover.hidden = true;
          }
        });
      });
    }

    function setLoadingState(isLoading, message) {
      if (isLoading) {
        status.textContent = message;
        results.classList.add('is-loading');
      } else {
        results.classList.remove('is-loading');
      }
    }

    function escapeHtml(value) {
      if (value === undefined || value === null) return '';
      return String(value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function formatRank(rank) {
      if (!rank || rank.rank == null || rank.total == null) return '—';
      const since = rank.since_year ? ` (since ${rank.since_year})` : '';
      return `${rank.rank} of ${rank.total}${since}`;
    }

    async function fetchResultRankings(meetId, eventName, resultType = 'Final') {
      if (!currentAthleteId) {
        throw new Error('No athlete selected.');
      }

      const params = new URLSearchParams({
        meet_id: meetId,
        event: eventName,
      });

      if (resultType) {
        params.set('result_type', resultType);
      }

      const response = await fetch(`/api/athletes/${currentAthleteId}/result-rankings?${params.toString()}`);
      if (!response.ok) {
        let detail = 'Unable to load rankings';
        try {
          const payload = await response.json();
          if (payload && payload.error) {
            detail = payload.error;
          }
        } catch (_err) {
          // ignore JSON parse errors
        }
        throw new Error(detail);
      }

      return response.json();
    }

    async function handleRankingButtonClick(event) {
      closeAllPopovers();
      const button = event.currentTarget;
      const row = button.closest('tr');
      const popover = row.querySelector('.ranking-popover');
      if (!row || !popover) return;

      const meetId = row.dataset.meetId;
      const eventName = decodeURIComponent(row.dataset.event || '');
      const resultType = row.dataset.resultType || 'Final';

      if (!meetId || !eventName) {
        return;
      }

      popover.hidden = false;
      const statusEl = popover.querySelector('.ranking-popover__status');
      const bodyEl = popover.querySelector('.ranking-popover__body');
      statusEl.textContent = 'Loading…';
      statusEl.hidden = false;
      bodyEl.hidden = true;

      try {
        const rankings = await fetchResultRankings(meetId, eventName, resultType);
        populateRankingPopover(popover, rankings);
      } catch (error) {
        statusEl.textContent = error.message || 'Unable to load rankings';
      }
    }

    function populateRankingPopover(popover, rankingPayload) {
      popover.hidden = false;
      const statusEl = popover.querySelector('.ranking-popover__status');
      const bodyEl = popover.querySelector('.ranking-popover__body');
      statusEl.hidden = true;
      bodyEl.hidden = false;

      const context = rankingPayload?.context;
      const cohorts = rankingPayload?.rankings || {};

      const detailsHeading = bodyEl.querySelector('h4');
      if (context && detailsHeading) {
        const { year, meet_type: meetType, event } = context;
        const pieces = [event, meetType, year].filter(Boolean);
        detailsHeading.textContent = pieces.length ? pieces.join(' · ') : 'Result Rankings';
      }

      const keys = [
        { key: 'overall', label: 'Overall' },
        { key: 'like_schools', label: 'Similar Enrollment' },
        { key: 'same_grade', label: 'Same Grade' },
      ];

      keys.forEach(({ key, label }) => {
        const container = bodyEl.querySelector(`.ranking-summary[data-cohort="${key}"]`);
        if (!container) return;

        const cohort = cohorts[key];
        if (!cohort) {
          container.innerHTML = `<p class="muted">No data available.</p>`;
          return;
        }

        const lines = [];
        lines.push(`<div class="ranking-summary__header">
          <span class="ranking-summary__label">${label}</span>
          <span class="ranking-summary__value">${cohort.rank} of ${cohort.total}</span>
        </div>`);

        if (cohort.criteria) {
          const criteriaParts = [];
          if (cohort.criteria.min_enrollment) {
            criteriaParts.push(`Enrollment ${cohort.criteria.min_enrollment}–${cohort.criteria.max_enrollment}`);
          }
          if (cohort.criteria.grade) {
            criteriaParts.push(`Grade ${cohort.criteria.grade}`);
          }
          if (cohort.criteria.enrollment && !cohort.criteria.min_enrollment) {
            criteriaParts.push(`Enrollment ${cohort.criteria.enrollment}`);
          }
          if (criteriaParts.length) {
            lines.push(`<div class="ranking-summary__criteria">${criteriaParts.join(' · ')}</div>`);
          }
        }

        const topResults = cohort.top_results || [];
        if (topResults.length) {
          lines.push('<ol class="ranking-summary__list">');
          topResults.forEach(entry => {
            const labelBits = [escapeHtml(entry.name || 'Unknown')];
            if (entry.school) {
              labelBits.push(`<span class="ranking-summary__school">${escapeHtml(entry.school)}</span>`);
            }
            if (entry.grade) {
              labelBits.push(`<span class="ranking-summary__grade">Grade ${escapeHtml(entry.grade)}</span>`);
            }

            lines.push(`
              <li class="ranking-summary__item ${entry.is_target ? 'is-target' : ''}">
                <div class="ranking-summary__placement">
                  <span class="ranking-summary__rank">${entry.rank}</span>
                  <span class="ranking-summary__result">${escapeHtml(entry.result)}</span>
                </div>
                <div class="ranking-summary__meta">
                  ${labelBits.join(' · ')}
                </div>
              </li>
            `);
          });
          lines.push('</ol>');
        } else {
          lines.push('<p class="muted">No leaderboard data available.</p>');
        }

        container.innerHTML = lines.join('');
      });
    }

    function closeAllPopovers() {
      document.querySelectorAll('.ranking-popover').forEach(popover => {
        popover.hidden = true;
      });
    }

    document.addEventListener('click', event => {
      if (event.target.closest('.ranking-popover__content') || event.target.closest('.ranking-button')) {
        return;
      }
      closeAllPopovers();
    });

    document.addEventListener('keydown', event => {
      if (event.key === 'Escape') {
        closeAllPopovers();
      }
    });
  });
</script>
{% endblock %}
